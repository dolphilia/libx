---
import type { LocaleKey } from '@docs/i18n/locales';
import { translate } from '@docs/i18n/utils';
import { defaultLanguageNames } from '@docs/i18n/language-names';
import Dropdown from './Dropdown/Dropdown.astro';
import DropdownItem from './Dropdown/DropdownItem.astro';
import Icon from './icons/Icon.astro';
import { getProjectConfig } from '@docs/project-config';

type LangPathInfo = {
  lang: string;
  name: string;
  path: string;
  isCurrent: boolean;
};

type FooterLink = {
  href: string;
  label: string;
  icon?: string;
};

interface Props {
  currentLang: string;
  supportedLangs?: string[];
  className?: string;
  languageNames?: Record<string, string>;
  baseUrl?: string;
  langPaths?: LangPathInfo[];
  footerLink?: FooterLink;
}

let projectConfig;
try {
  projectConfig = await getProjectConfig();
} catch {
  projectConfig = undefined;
}

const {
  currentLang,
  supportedLangs,
  className = '',
  languageNames,
  baseUrl,
  langPaths,
  footerLink,
} = Astro.props;

const combinedLanguageNames = {
  ...defaultLanguageNames,
  ...(projectConfig?.language?.displayNames ?? {}),
  ...(languageNames ?? {}),
};

const resolvedSupportedLangs =
  supportedLangs?.length > 0
    ? supportedLangs
    : projectConfig?.language?.supported ?? [currentLang];

const normalizedBaseUrl =
  typeof baseUrl === 'string'
    ? baseUrl.replace(/\/$/, '')
    : projectConfig?.paths.baseUrl?.replace(/\/$/, '') ?? '';

const fallbackLangPaths = resolvedSupportedLangs.map((langCode) =>
  createFallbackPath(langCode)
);

const resolvedLangPaths =
  langPaths && langPaths.length
    ? langPaths
    : projectConfig
    ? computeLangPathsFromProjectConfig()
    : fallbackLangPaths;

const validLangPaths = resolvedLangPaths.length ? resolvedLangPaths : fallbackLangPaths;
const dropdownLabel = combinedLanguageNames[currentLang] ?? currentLang;

function createFallbackPath(langCode: string): LangPathInfo {
  let path = normalizedBaseUrl
    ? `${normalizedBaseUrl}/${langCode}`
    : `/${langCode}`;

  if (!path.startsWith('/')) {
    path = `/${path}`;
  }

  path = path.replace(/\/\/+/g, '/');

  if (!path.endsWith('/')) {
    path += '/';
  }

  return {
    lang: langCode,
    name: combinedLanguageNames[langCode] ?? langCode,
    path,
    isCurrent: langCode === currentLang,
  };
}

function computeLangPathsFromProjectConfig(): LangPathInfo[] {
  if (!projectConfig) {
    return [];
  }

  const currentPathname = Astro.url.pathname;
  const normalizedPathname = currentPathname.endsWith('/')
    ? currentPathname
    : `${currentPathname}/`;

  const baseUrlFromConfig = projectConfig.paths.baseUrl
    ? projectConfig.paths.baseUrl.replace(/\/$/, '')
    : '';

  let pathWithoutBase = normalizedPathname;
  if (baseUrlFromConfig && normalizedPathname.startsWith(`${baseUrlFromConfig}/`)) {
    pathWithoutBase = normalizedPathname.substring(baseUrlFromConfig.length);
  } else if (normalizedPathname === `${baseUrlFromConfig}/`) {
    pathWithoutBase = '/';
  }

  const pathSegments = pathWithoutBase
    .split('/')
    .filter((segment) => segment.length > 0);

  let versionFromPath: string | undefined;
  let langFromPath: string | undefined;
  let slugParts: string[] = [];

  if (pathSegments.length > 0 && /^v\d+([.-]\d+)*$/.test(pathSegments[0])) {
    versionFromPath = pathSegments.shift();
  }

  const langsForRegex = resolvedSupportedLangs.join('|');
  const langRegex = langsForRegex ? new RegExp(`^(${langsForRegex})$`) : null;

  if (langRegex && pathSegments.length > 0 && langRegex.test(pathSegments[0])) {
    langFromPath = pathSegments.shift();
  }

  slugParts = pathSegments;

  let slugFromPath = slugParts.join('/');
  if (slugFromPath && !slugFromPath.endsWith('/')) {
    slugFromPath += '/';
  } else if (!slugFromPath && slugParts.length === 0 && (langFromPath || versionFromPath)) {
    slugFromPath = '';
  }

  return resolvedSupportedLangs.map((langCode) => {
    const pathChunks = [baseUrlFromConfig];

    if (versionFromPath) {
      pathChunks.push(versionFromPath);
    }

    pathChunks.push(langCode);

    if (slugFromPath && slugFromPath !== '/') {
      const cleanSlug = slugFromPath.endsWith('/')
        ? slugFromPath.slice(0, -1)
        : slugFromPath;
      if (cleanSlug) {
        pathChunks.push(cleanSlug);
      }
    }

    let newPath = pathChunks
      .filter((chunk) => typeof chunk === 'string' && chunk.length > 0)
      .join('/');

    if (!baseUrlFromConfig && newPath && !newPath.startsWith('/')) {
      newPath = `/${newPath}`;
    }

    newPath = newPath.replace(/\/\/+/g, '/');

    if (newPath !== '/' && !newPath.endsWith('/')) {
      newPath += '/';
    }

    return {
      lang: langCode,
      name: combinedLanguageNames[langCode] ?? langCode,
      path: newPath || '/',
      isCurrent: langCode === currentLang,
    };
  });
}
---
<div class="language-selector-container">
  <Dropdown
    label={dropdownLabel}
    align="right"
    width="14rem"
    class={`language-dropdown ${className}`}
  >
    <div class="language-dropdown-header" slot="before-items">
      <Icon name="languages" class="language-icon" />
      <span>言語を選択</span>
    </div>

    {validLangPaths.map((pathInfo) => (
      <DropdownItem
        label={pathInfo.name}
        href={pathInfo.path}
        isActive={pathInfo.isCurrent}
      >
        {pathInfo.isCurrent && (
          <span slot="after-label" class="language-current-badge">
            {translate('docs.current', currentLang as LocaleKey)}
          </span>
        )}
      </DropdownItem>
    ))}

    {footerLink && (
      <div class="language-dropdown-footer" slot="after-items">
        <a
          href={footerLink.href}
          class="language-footer-link"
          target="_blank"
          rel="noopener"
        >
          <Icon name={footerLink.icon ?? 'external-link'} class="language-footer-icon" />
          {footerLink.label}
        </a>
      </div>
    )}
  </Dropdown>
</div>

<style>
  .language-selector-container {
    display: inline-block;
  }

  .language-dropdown {
    position: relative;
  }

  .language-dropdown-header {
    padding: 0.5rem 1rem;
    font-size: 0.875rem;
    font-weight: 500;
    color: var(--sl-color-gray-5, #6b7280);
    border-bottom: 1px solid var(--sl-color-gray-2, #e5e7eb);
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }

  .language-dropdown-footer {
    padding: 0.5rem 1rem;
    border-top: 1px solid var(--sl-color-gray-2, #e5e7eb);
  }

  .language-footer-link {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    font-size: 0.875rem;
    color: var(--sl-color-primary, #2563eb);
    text-decoration: none;
    transition: color 0.2s ease;
  }

  .language-footer-link:hover {
    color: var(--sl-color-primary-dark, #1d4ed8);
    text-decoration: underline;
  }

  .language-footer-icon {
    font-size: 1rem;
    color: currentColor;
  }

  .language-icon {
    font-size: 1rem;
    color: var(--sl-color-gray-4, #9ca3af);
  }

  .language-current-badge {
    display: inline-flex;
    align-items: center;
    padding: 0.125rem 0.5rem;
    border-radius: 9999px;
    font-size: 0.75rem;
    font-weight: 500;
    line-height: 1;
    background-color: var(--sl-color-blue-2, #dbeafe);
    color: var(--sl-color-blue-9, #1e40af);
  }

  :global(.dark) .language-dropdown-header,
  :global(.dark) .language-dropdown-footer {
    border-color: var(--sl-color-gray-7, #374151);
  }

  :global(.dark) .language-current-badge {
    background-color: rgba(30, 64, 175, 0.2);
    color: var(--sl-color-blue-3, #93c5fd);
  }

  @keyframes fadeIn {
    from {
      opacity: 0;
      transform: translateY(-0.25rem);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  .language-dropdown :global(.dropdown-content) {
    animation: fadeIn 0.2s ease-out;
  }
</style>
